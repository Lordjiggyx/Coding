Technologies used 

MongoDB
Nodejs
Reactjs
Expressjs
Reactstrap
Redux
React-transition-group
==heroku for live deployment==



===PART 1 - EXPRESS API & MONGODB===

To start we will create our package.json file using 

npm init -y 

We will then go to intstall a number of dependencies

express
body-parser
mongoose
concurrently
nodemon*** might need to save as a dev dependency as not required for production

npm i  --save express body-parser mongoose concurrently

we need ot create to scripts to run the application in the package.json

"start": "node server.js",
"dev": "nodemon server.js",

We can then create our server.js file

---Server.js---

and in this file we can bring express mongoose and body-parser

const express = require("express")
const mongoose = require("mongoose")
const bodyParser = require("body-parser")

we then initialze express to an app variable 

const app = express()

Body parser needs middleware 

app.use(bodyParser.json())

--Connecting to Database--
Rather then using command line for the MongoDB i'm going to use MongoDB compass as it makes htings much easier 

Create a databas and a collection called items 

create item objects with the attributes name author and date



To conect to MongoDB

we need to create a config folder and store our mongo conection url in a file called keys.js

we then use modules.exports 

we let this export an object containing our keys for example the mongo url

module.exports = 
{
    MongoUrl:"mongodb+srv://Tomi:<Lordjiggy123.>@testcluster1-bsyse.mongodb.net/MERN?retryWrites=true&w=majority"
}
******To get your application to interact with a certain database in atlas after the .mogodb.net/ you must change the vlaue to the name of the database******

we can then bring this into our app.js file and connect to the database

to do this we create a databse variable and allow it to require the keys files and we request the mongo url

const db = require("./Config/keys").MongoUrl

we then use mongoose.connect to connect to the database

this takes in the database variable and an object called useNewUrlParser which must be set to true this returns a promise which we can just console.log the database is Connected and then a catch where we can just log the error

mongoose.connect(db , {useNewUrlParser:true})
.then(()=> console.log("Connected To Database..."))
.catch(err => console.log(err))

We can then create a variable for the port as we may use heroku to deploy it we will set this variable to an environment variable or set it to a local port of 5000

const port = process.env.PORT || 5000

then we can call the app.listem method to start the server passing in the port variable and returning a callback indicating the port is started

app.listen(port , ()=>
{
    console.log(`Server strated on port ${port}`)
})

now we will use npm run dev to strat our server


===Model===

The next thing we will be creating is a model which is a model of our data and the fields we want 

To do this we will create a folder called modles and crete a file called Item.js


In this file we will bring in mongoose and and then create a schema

const mongoose = require("mongoose")

The schema is named after the data so it will be called ItemSchema it will be set to a new mongoose schema

const ItemSchema = new mongoose.Schema(
    {
        ...
        ....
        .....
    }

This schemaa object will take a name and date field

we then create an Item variable and then set it to equal the mongoose.schemaa and this will taje in the name of the data baeing created which is an item and the schema that represents it

let Item = mongoose.model("Item" , ItemSchema)

Then we can export this using module.exports

module.exports = Item


===Routes===
We need to creat a folder called routes for our routes in the project and in this folder we will cretae a folder called API

The Api routes will return JSON 

****we are not using a template engine****

in the api older we will create a file called items.js which all our routes will go 

for this file to work we need to include it in our app.js file so the application knows where to look for it 

in our app.js we will create a variable called items.js and require the path of the items.js file 

const Items = require("./Routes/api/items")

we then want to make it so any request targeted at /routes/api to target items.js

To do this we will call app.use() and point to the items file by referencing the variable

//Use Routes
app.use("/Routes/api/", Items)

---Items.js---

We can then go into our items.js and bring in express then we must use the express router 

//Bringing in express
const express = require("express")
//Using express router 
const router = express.Router()


****Export This file using module.exports******


We must then bring in the item model in oirder to manipulate the items 

//Bringing in Item model
const Item = require("../../models/Item")

Now in the items.js file we will create our routes 


---Items routes---

The first route will be a get request to retrieve all items

router.get("/" , (req , res)=>
{
    
})

to fetch all the items in the database

we will first take the model(Item) and then use the find method

this method returns a promise and in this function it will return the items and then we will send a json response using  res.json and pass in items

we can also tag on a .sort() method in order to sort the items by date 1 for ascending and -1 for descending

router.get("/" , (req , res)=>
{
    Item.find()
    .sort({date:-1})
    .then(items =>res.json(items))
})

we then want to create aa route for creating an item this will use router.post 


router.post("/" , (req , res)=>
{

})

in here we will create an item variable set it to be a new item object and we just pass in the name variable from the request which is llowed by using body parser 


router.post("/" , (req , res)=>
{
   const newItem = new Item(
       {
           name: req.body.name
       }
   )
    console.log("Page working")
})

we can then call the newItem.save() method which will save it to the database this returns a promise which returns the object and we will send out a json repsonse seding out the item


router.post("/" , (req , res)=>
{
   const newItem = new Item(
       {
           name: req.body.name
       }
   )

   newItem.save()
   .then(item =>
    {
        res.json(item)
    })
    console.log("Page working")
})


We will then call a delete request This will be based off the id of the item

//Route for deleting a post
router.delete("/:id" , (req , res)=>
{
    //Finiding the Item to delete by ID
   Item.findById(req.params.id)
   //This returns a promise which gives us trhe found item and then a callback of what we want to happen
   .then(item =>
    {
        //We want to use thr remove method on the model and then send a message saying the item was deleted
        Item.remove()
        .then(()=> console.log("Item Deleted"))
        //We then want a catch method this method will return an err and a callback this callback will return a 404 not found message and a messgae to indicate that there was an error
        .catch(err =>res.status(404).send("Error"))
    })
   
 console.log("Page Working")
})


===Part 2 Setting up the Client and Reactstrap====

We will start to work on the front-end focusing on React

To start we need to create a new folder called Client

This is where our react app will go 

in this folder we will use create-react-app . to specify that we want to cretae a a react apploication in this folder

This package.json it creates is different from your package.json in the root folder

****When you are building a full stack app like this you need a proxy value in the package.json in the client folder *****

,
  "proxy": "http://localhost:5000/"

This way the application knows what we are talking about when we make calls to the endpoint in

--Run Both Servers--

We then want to run both servers at the same time 

to do this we can use concurrently which wil allow us to run both at the same time

To do this we open the package.json in the server side of the application and then create a few scripts 

"client": "npm start --prefix client" This is to run the client server from the server directory


 "Both": "concurrently \"npm run dev\" \"npm run client\" " This will allow us to run both servers together the backslahes are used for character escaping 

"client-intstall": "npm install --prefix client" 2 -This is done as if this app is being cloned or moved it will stop the need to reinstall the node_modules folder and run npm install 

this way you can just use npm run client install to install all the client dependencies

so we can now cd back to the root folder and call npm run both

--React Client Side--

In this folder there are extra default things we will delete the following 

logo.svg
index.css

we can go into the app.css and remove the Code

remove any sort of calls that reference deleted files 

in the app.js file we can remove all the code an djust keep the div tag and pss in hello world

import React from 'react';
import './App.css';

function App() {
  return (
    <div className="App">
     <h1>Hello World</h1>
    </div>
  );
}

export default App;

We have a few dependencies to add to the application 

we can open a new terminal and go into the client folder

now we want to install 
bootstrap
Reactstrap
uuid used for static data at the moment to genereate random numbers

npm i bootstrap reactstrap uuid react-transition-group

---Components--

We need to import bootsrap into our app.js 

import "../../client/node_modules/bootstrap/dist/css/bootstrap.css"

**Must be at proper directory path**
**If the page does not load turn the server off and on**


We will create a folder called Components in the src folder


-Navbar-
In the Components folder we will creeate a fille called AppNavbar

We will import react and the Component from react 

import React , {Component} from "react"

We will then import a few things from reactstrap

import
{
    Collpase, - This is for teh toggler in the case we add more links to a responsive hamburger menu
    Navbar, - The Navbar
    NavbarToggler, - Used in conjuction to Collpase
    NavbarBrand, - The brand for the Navbar
    Nav, - Wrap around the links
    NavItem, - wrap around nav links
    NavLink, - this wil be where the href is
    Container, bootrap container for everything
} from "reactstrap"

Then we will create our class 

class AppNavbar extends Component
{

    constructor(props)
    {
        super(props)
        this.state = {}
    }


    render()
    {
        
        return(
            <div>

            </div>
        )
    }
}

export default AppNavbar


***We will be passing in props to our navbar so we must pass in props in the navbar and hte super***

We will then create the toggle function 

toggle = () =>
{

}

The toggle funtion here has been set to an arrow function this is a work around for having to bind the the function in the constructor like you usually would and you can do this for any custom function

then in our state we can add isOpen:false , this is the variable that will halp us toggle the hamburger menu 

then in our toggle method we can use this.setState to change the value of isOpen to whatever the oppposite is to allow toglle

toggle = () =>
        {
            this.setState({
                isOpen: !this.state.isOpen
            })
        }

in our render function we will render our navbar using the react Components

First we will place the navbar in the div 

<Navbar color = "success" dark expand = "sm" className="mb-5">
            
</Navbar>

The navbar can take attributes like normal html ones wouls 
color is for the bootstrap colors success = green

expand means that it will become a hamburger menu on small screens as we set it to sm 

className mb-5 means margin-bottom 5

we place dark for the text on the page

we will then place a container in this 
then we can place our NavbarBrand and allow it to have a href to the index page 

<NavbarBrand href = "/">
      The M.E.R.N Shopping List
</NavbarBrand>

Next is the NavbarToggler we give this an onclick and pointit to carry out the toggle method

<NavbarToggler onClick={this.toggle}/>

Then we must add the Collpase we add the isOpen attributes and set it to be the value of isOpen in the state of the clsss we place navabr to let the application know that it's part of a navbar 

<Collapse isOpen = {this.state.isOpen} navbar>

then we add the nav with a class if ml auto just ot make sure that the nav bar is aligned to the left and the link is alligned to the right 

<Nav className = "ml-auto" navbar>

we then add the NavItem link to wrap the link and then the nav item , the nav item taks a href of where you want to send the client with text inside

<NavItem>
    <NavLink href= "https://youtube.com">
        Click To Go to Youtube
    </NavLink>
</NavItem>

In total the AppNavbar looks like this 


 <div>
<Navbar color = "success" dark expand = "sm" className="mb-5">
    <Container>
        <NavbarBrand href = "/">
            The M.E.R.N Shopping List
        </NavbarBrand>
        <NavbarToggler onClick={this.toggle}/>
        <Collapse isOpen = {this.state.isOpen} navbar>
            <Nav className = "ml-auto" navbar>
                <NavItem>
                    <NavLink href= "https://youtube.com">
                        Click To Go to Youtube
                    </NavLink>
                </NavItem>
            </Nav>
        </Collapse>
    </Container>
</Navbar>
</div>


Then we must go into our app.js and import this Component

import AppNavbar from "../src/Components/AppNavbar"

and then in the div we can return the AppNavbar tag 

function App() {
  return (
    <div className="App">
    <AppNavbar></AppNavbar>
    </div>
  );
}



===Part 4 - Shopping list Components and Transitions====

In our Components file we will create a new fille called shopplnnglist.js this will be a class based component

we need to import react 

//Importing react and the components
import React , {Component} from "react"

we need to import things from reactstrap

import {
    Container,
    ListGroup,
    ListGroupItem,
    Button
} from "reactstrap"

Then we need to import things from react-Transition-group
import { CSSTransition , TransitionGroup} from "react-transition-group"


we import uuid for our list items id's
import uuid from "uuid"

We can start by creating the shopplnnglist Component

At the momeent we will hardcode the data into the state 


this.state =
    {
         items:
         [
             {id:uuid() , name: "Chicken"},
             {id:uuid() , name: "Pudding"},
             {id:uuid() , name: "Rice"},
             {id:uuid() , name: "Chicken"}
         ]
    }

in our rrender method we can destructure our state and pull out the items array

 const {items} = this.state

Then in our return we can start by creating a container tag
and in this container we will create a button to add the item 

In the button tag we can add attributes one for the color and an inline style of a margin botttom of 2 rem 

then rather then creating a whole new function to handle the onclick we will use and arrow function 

in this arrow function we will create a variable that will be a prompt for the user to enter a name for the item called name 

then we will create an if statement thhat says if name exists we will change the state but in the this.setState method we will use the spread operatoron the array to add the new object to the array of Items then we close all the tags

explanation of the spread syntax here 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax

 <Container>
                <Button 
                color = "dark"
                style={{marginBottom:"2rem"}}
                onClick = {()=>
                {
                    const name = prompt("enter Item")
                    if(name)
                    {
                        this.setState(state =>
                        (
                            {
                                items:
                                [...state.items,
                                {id:uuid() , name:name}
                                ]
                            }
                        ))
                    }
                }}>
                        Add Item
                </Button>
            </Container>


To dispay the buttons we will go underneath the button and use a list group tag
we want to map through all the items and display each one 

<ListGroup>

we will be using the transition group tag and give it a class name of shopping-list
<TransitionGroup className = "Shopping-list"

inside this tag we will use the map higher order array funciton , we will destructure the item object and grab just the name and id of the items 

{items.map(({id, name}) => (


))}

for each item we will display a ListGroupItem but wee want the transition effect to occur first we will use the CSSTransition tag this will take a key which will be the id of the item is then we will set a tineout and finally it needs a classname attribute of fade then we will have to add css to the className for the fade to happen 

then inside this tag we will place the ListGroupItem tag and we will display the name

<ListGroup>
    <TransitionGroup className= "shopping-list">
        {items.map(({id , name})=> (
        <CSSTransition key = {id} timeout= {500} classNames= "fade">
        
        <ListGroupItem>
            {name}
        </ListGroupItem>

        </CSSTransition>
        ))}
    </TransitionGroup>
</ListGroup>

Before the name we will add a delete button thr button will take in properties 

a className
the colour
the size 
an onclick

  <Button
    className= "btn-del"
    color = "danger"
    size = "sm"
    onClick = {()=>{}}
    >

in th onclick we will call the this.setState method , we will take the current state and then the items variable and the state of this value we will use ht filter method to return a mew array without the clicked item

This method returns each item along with a condition , this condition will be if the item id is not equal to the id, whatever item we click on will actually remove the item from the UI 

 onClick = {()=>
{
    this.setState(state =>(
        {
            items: state.items.filter(item => item.id !== id)
        }))
}}

we can then go to our app.css and edit the button and make the fade transition happen

.fade-enter{
opacity: 0.01;
}

.fade-enter-active
{
opacity: 1;
transition: opacity 1000ms ease-in
}

.fade-exit{
    opacity: 1;
    transition: opacity 1000ms ease-in
}

.fade-exit-active
{
    opacity: 0.01;
}

fade-enter & fade-enter-active are the tramsitions that happen wehen we add an item to the list we want it to start off as invisible usin the opacity property and then become visible we set the duration to be one second or how long you wnat it

the fade-exit and fade-exit-active is the opposite when we delete an item

We then must go to our app.js and add the component


====Part 5 Implementing Redux====

CARS = Component => actions => Reducer => store

We are Implementing redux in order to create a component called an item modal component which will interact with our redux state , There is a lot of boilerplate 

To start we need to install a few things
***We must be in the client Folder***

redux - The redux itself
react-redux what binds the two
redux-thunk - middleware for dealing with back end for dispatching from actions to our reducer when we want to make async calls

we must intsall redux , react-redux , redux-thunk

npm i --save redux react-redux redux-thunk

Then in our src folder in the client folder we will cretae a file called store .js

This will be the starting point of our redux store , the only way to cahnge this is by calling an action

so in this store.js file we need to import  a few things


import {createStore , applyMiddleware ,compose} from "redux"
import thunk from "redux-thunk"
import rootReducer from "./Reducers/index"

we eill create a variable to represent our initail state 

const iniialState = {}

Then a variable for middleware being used and we will store these in an arrau

const middleware = [thumk]

Then a variable called store and set it to be our createStore function , this will take in three things our rootReducer , iniialState and any middleware but since were using redux tools we will pass the applyMiddleware into the compose function and in this applyMiddleware function we can pass in thunk using the spread Operator

const store = createStore(rootReducer , initialState , compose(
    applyMiddleware(...middleware)
))

To use the redux dev tools we must insert a line of code inside 

 window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()

 thne we can just export the store 

 export default store

 in oreder to integrate the store into our application we need to go into our app.js and bring in the provider, this is from react-redux 

 in order to use redux in our components and manipulate state we must wrap everything in the provider tag , this tag takes in a property of our store  

 
function App() {
  return (
    <Provider store = {store}>
    <div className="App">
    <AppNavbar></AppNavbar>
    <ShoppingList></ShoppingList>
    </div>
    </Provider>
  );
}

This will allow us to access state from the components

next we will create the rootReducer this will be done in the src folder we will create a folder called reducers and then a file called index.js

The main point of this is to bring together all the other reducers , this is a simple app so we only have itemReducer if we were to add authentication or manage errors we might need an authentication reducer of error reducer.

so to start we will import combinereducers
import {combineReducers} from "redux"

and then itemReducer which we have not created yet but we will 

import itemReducer from "./itemReducer"


Then we will export combineReducers and pass in an object with the different reducers and we will set itemReducer to a value called item which will help us identify it within components when we wnat to use it

Next we will creeate our itemReducer in the reducers file called itemReducer.js

******************************************************************************
A reducer is where our actual state is going to be , this is wher we check our actions , we will have an actions file which will contain our actions for getting items or adding items actions and dispatch to our reducer , it can send a payload 

So say we were to fetch data from our server for the grtting items we would then dispatch to the reducer and send the response from our server to the reducer and then manipulate it within react in our components
******************************************************************************

So Going back to this itemReducer.js file we will create our iniialState this will be an object with an items array 

const initialState= 
{
    items:
         [
             {id:uuid() , name: "Chicken"},
             {id:uuid() , name: "Pudding"},
             {id:uuid() , name: "Rice"},
             {id:uuid() , name: "Chicken"}
         ]
}

***You need to import uuid***


in this reducer we need to evaluate action types , so we need to create types 
we will cretae a folder called actions in the src file 

and in this file we will have afile called types.js this can also be called "constants" , they are just constants set to strings that we export

export const GET_ITEMS = "GET_ITEMS"
export const ADD_ITEMS = "ADD_ITEMS"
export const DEL_ITEMS = "DEL_ITEM"

***Any thing you do in your application you will add an actionn type for***

We can then bring this inot our item reducer

back into the itemReducer.js we will import the actions
import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS } from "../actions/types"

in our itemReducer.js we want to export a fucniton this function takes two paramaters first is the state whihc we will set to our initial state and then secondly it will take an action object which will have a type attached to it from the actions file that we haven't created yet 

export default function (state =initialState , action)
{
   
}


in this function we will have our switch statement when the action comes in we wnat to run a test on the type , as actions is an object we can access the type using actions.type and we will check for the action name 

at the momeent with the GET_ITEMS we will just use the spread Operator to return the current state this will be changed when we connect to the backend 

 switch(action.type)
    {
        case GET_ITEMS:
            return {
                ...state
            }
        default:
            return state;
    }

Next we want an actions file in our actions folder called itemActions.js this is where we wil be maing backend requests

we need to import our tuypes into the file

import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS } from "../actions/types"

we can then export an arrow funciton whihc returns the type to the reducer in this case it will be GET_ITEMS

export const getItems = () =>
{
    return{
        type:GET_ITEMS
    }
}


This goes to our itemReducer and checks action.type 

now we want is to call the getItems from our component instead of getting it from the state we want to grab it from our itemReducer

Now in our ShoppingList component we must make a few chnages 

first we must import connect from react redux this allows us to get state from redux into a react component 

import {connect} from "react-redux"

Then we need to import the getItems action this is being taken from the actions folder and the itemActions file 

when we use connect like this instead of exporting the actual clsss we want to export connect with parentheses which will take in two things a function called mapStateToProps which is a function we haven't created yet and thne it will take in any actions we want to use in this case being getItems and then the class naem wrapped around in brackets 


export default connect(mapStateToProps , {getItems})(ShoppingList)


What mapStateToProps allows us to take our state in itemReducer and map this into a component property which will let us access it it using this.props.items


we must create the function mapStateToProps, this will use an arrow function and it takes in state and then we want to set it to parentheses and then pass in an object and then we want to set item to state.item **We use state.item cause that is what we called the reducer in th rootReducer**

const mapStateToProps = (state) =>
({
    item:state.item
})

next we want to bring in our prop types whenever you have component properties they should be put into prop types which is like a form of validation 

import PropTypes from "prop-types"

Then underneath the class we can then  type shopplnnglist.propTYpes and set it to {} we have two props in this component , the first is getItems , when you bring na action from redux it's stored as a prop so we can set this to PropTypes.func.isRequired  and then set item to PropTypes.object.isRequired

ShoppingList.propTypes = 
{
    getItems: PropTypes.func.isRequired,
    //This is our state which is an obejct
    item: PropTypes.object.isRequired
}



The last thing to run get items

to do this we want to run it in a componentDidMount function call within our class

componentDidMount()
{
    this.props.getItems()
}


we must now cahnge the way we accessed the items by using 

this.props.item.items

item represents the state object 
items is the array inside the state

so we can use destructuring again just target a different object this time

 const {items} = this.props.item





To help you better understand how redux is working in this application you must remember that the ShoppingList COMPONENT is connected to the Redux store through connect. So, when you click the delete button it fires the deleteItem ACTION. In his tutorial, he has the dispatch inside his action creator, so the action itself will initiate the STORE to call the reducer. The REDUCER will then check which action will be executed then return the correct behavior to the STORE. It looks a little something like this:
Component (click) --> Action(dispatch) --> Store (sends action to reducer) --> Reducer (returns new state AS item) --> Store


===Part 6 Finsihing Redux===

first thing we want to do is the delete

we will rmeove uuid remove any instance of uuid in the component and then renmove the button as we will create a separate component for adding items

in our shopplnnglist component we will bring in the delItems actions along with getItems at the top

import {getItems , delItems} from "../actions/itemActions"

 and also include in the export at the bottom 

 export default connect(mapStateToProps , {getItems , delItems})(ShoppingList)

 Now we go to our itemActions.js and then create a new const called delItems this wiill take in an id to identify which element to delete  and change the type tO DEL_ITEM

export const delItems = (id) =>
{
    return{
        type:DEL_ITEMS
    }
}


 To get the id we must send along a playload if the id that i spassed into the function 

export const delItems = (id) =>
{
    return{
        type:DEL_ITEMS,
        payload:id
    }
}


  This is returining to the reducer so we must go to the reducer and check for DEL_ITEM. we must now add a case for delete 

  case DEL_ITEMS:
            return {
                
            }

To start we want to grab the state using the spread Operator then

 case DEL_ITEMS:
            return {
                ...state
            }

then we eill take the items and then calle the filter method on them and then do what we did previosuly returning an item and each time the item is retuerned we check that the id of it does not equal the value of the clicked identify

in this case however in our action we passed in a payload whihcwe can access using action.payload

case DEL_ITEMS:
            return {
                ...state,
                items: state.items.filter(item => item.id !== action.payload )
            }


Then going back to our component we will change the onclick to a function we create called onDeleteClick , this method must take in the id of the clicked item and to do this we can use bind and pass in this and id 


 onClick = {this.onDeleteClick.bind(this , id)}

 then we can create the method we set this this will be an arrow function whihc tajes in the id and then it calls the action delItems passing in the id

 onDeleteClick = (id) =>
{
    this.props.delItems(id)
}

This then sets the type to DEL_ITEMS and creates a payload with the id value inside this then called the reducer which exceutes the delete method which is explained above 


In our components folder we will create a new file called itemModal.js

in this file we will import react and a number of components from reactstrap


import React, { Component } from 'react'
import {
    Button,
    Modal,
    ModalHeader,
    ModalBody,
    Form,
    FormGroup,
    Label,
    Input
  } from 'reactstrap';

  

  A container is a component that is hooked to redux if you are using redux state in a component it is called a container


  we must import connect and the additem action which we have not created yet 

import { connect } from 'react-redux';
import { addItems } from "../actions/itemActions"

  To start we will give the modal state and we will set modeal to false this represents if the modal is open or not we will have a form which will have the item name so we need to give our component state too , in the case where you have a form you want the input to have state in the component 

  
    state = {
        modal: false,
        name : " "
    }
   
   , we will also have a toggle like the navbar and allow it to vhnage the modal vakue to the opposite of it's current value

   toggle = () =>
   {
       this.setState(
           {
               modal = !this.state.modal
           })
   }



Then in our render method we will place a button within our div , this button wil open the modal same button as our last one


 <Button 
color = "dark"
style={{marginBottom:"2rem"}}
onClick ={this.toggle}
>
Add Item
</Button>

under the button is where we will place the modal 
it will take a few paramaters 

isOpen - set to this.state.modal to tell uf the modal is open or not
toggle - set to toggle function


<Modal
isOpen = {this.state.modal}
toggle = {this.toggle}
>

After the modal we will have the modal header this will also have a toggle attribute in it

<ModalHeader toggle = {this.toggle}>
Add to Shopping list
</ModalHeader>

then we will have the ModalBody
inside the ModalBody we will have a form this form takes an onsubmit attribute and we will set this to a mtehod called onsubmit that we wil create 

  <Form onSubmit = {this.onSubmit}>


inside the form tag we will place a FormGroup tag and inside this FormGroup we will use the Label and Input tags the Label will have an attribute called "for" and this will be set to item 

<Label for = "item">
Name
</Label>

The input will take in a few attributes
type - text
name - this value should match the name of the state you are affecting
id- set to item
placeholder- whatever you want

onChange - In react when you have an input you want ot set it to a function called onChange whihc we will create 

 <Input
type = "text"
name = "name"
id = "item"
placeholder = "Enter Item"
onChange = {this.onChange}
/>

Then we will create a button just for submitting the name to the state 

 <Button
color = "dark"
style={{marginTop:"1rem"}}
block
>
Submit
</Button>

we use block so it fits the whole container


We will then cretae the onChange and onSubmit methods 


The onChange will be set to an arrow function this will take in an event paramater inside the function we will use this.setState , we're actually going to use e.target.name this targets the name of the input which should have a matching vlaue in thwe state so if we had multiple inputs we would not have to create multiple functions for one input. Then we can set this to be the e.target.value

onChange = (e) =>
   {
       this.setState(
           {
              [ e.target.name]:e.target.value
           }
       )
   }

The onsubmit will also be an arrow function that takes in an event paramater, we first need to prevent the form from acting how it would naturally at the momeent were not dealing with the backend so we will create an item with a uuid ID and the name value will come from the state when we type into the input it updates the state name 

const newItem = 
{
id:uuid(),
name:this.state.name
}

we now will add the item through the addItem action to do this we use this.props.additems() and then pass in newItem 

 this.props.addItems(newItem)

 and then you can close the model using this.toggle



  before we create our addItems action we need to export our component with model withn connect and create a mapStateToProps function 

  we must create the function mapStateToProps, this will use an arrow function and it takes in state and then we want to set it to parentheses and then pass in an object and then we want to set item to state.item **We use state.item cause that is what we called the reducer in th rootReducer**

const mapStateToProps = (state) =>
({
    item:state.item
})

then to export our object we must use connect passing in this mapStateToProps functino along with the addItems action and then the itemModal

  export default connect(  mapStateToProps, { addItem } )(ItemModal)

Now we must go to our itemActions.js and create the add item 

export const addItems = (item) =>
{
    return{
        type:ADD_ITEMS,
        payload:item
    }
}

instead of id this action will takje in the whole item , and the type we want to return to the reducer is ADD_ITEMS and along with that a payload if the item object itself


Then we must go to our redcucer and then create a case for ADD_ITEMS and we want to return the current state using the spread Operator and then set items to equal the item from the action.payload and use the spread Operator to add it to the state of the items 

Then in our app.js we can import and add the itemModal

====Part 7 - Connecting to the backend====

Now we will Implement the backend by making requests to it from the front end by doing this in the actions 

in the itemredcucer.js we will get rid of the static data and add a loading value and make this boolean

we need another type in pur types and this will be called ITEMS_LOADING

import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS , ITEMS_LOADING} from "../actions/types" 

and we will have to create this in our action types

export const ITEMS_LOADING = "ITEMS_LOADING"

Then back in our itemReducer.js we will add ITEMS_LOADING as a case , all this will do will cahnege the isloading value in the state to true 

  case ITEMS_LOADING:
                    return {
                        //we use spread to get current state 
                        ...state,
                        //Then we can just set the state of the loading value to eqaul true 
                        loading:true
                    }

Then in our itemActions.js we need ot create another funciton called setLoading

to start we must bring in ITEMS_LOADING at the top

import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS  , ITEMS_LOADING} from "./types"

and then we will create the function exporting it at the same time this will be an arroe function
all this function will do is retun the type of ITEMS_LOADING which ultimate;y sets it from false to true 

--GET_ITEMS Action--

Now we will fetch the items to make requests we will use axios , to use axios we must first install it using npm i --save axios and this should be done within the client side 

onec this is installed we need to import it into our file using 

import axios from "axios"

Then we will add another arrow function and add dispatch to the function 

export const getItems = ()=> dispatch =>
{

}

we want to call setLoading by using dispatch() and passing on setLoading() into this method

dispatch(setLoading())

we can then make our axios request using axios.get in here we will pass in the route from our back end that fetches the data which was "/routes/api/items"

axios.get("/routes/api/items")

this will then return a promise using .then 
and in here we will be given our response obejct in which we will return
 dispatch()

and inside the dispatch we will pass in curly braces and set the type which will be GET_ITEMS and then set the payload to res.data whihc is the data given to us from the back end when we make this request 
.then(res => 
        dispatch(
            {
                type:GET_ITEMS,
                payload: res.data
            }
        )
        ) 

Then we go to the reducer and go to our GET_ITEMS case we now want to get the items array which is blank and populate it with the new items from the action.payload

items:action.payload,

We then want to set isloading to false which shows that the fetching has been finished 


--Add items--
This will be the same thing in our itemredcucer.js

we will add the dispatch 

export const addItems = (item)=>dispatch =>

then we will make an axios post request to our target route which is the same 
"/routes/api/" we need to pass along data whihc is our item and htis will be passed into the axios.post request 

axios.post("/routes/api/" , item)

but we need to go to our onsubmit method in our item modal we want ot remove the uuid cause MongoDB creates the id for us

now a promise is returned again giving us a response and then we will do the same thing again setting it to dispatch and again passing in curly braces where we set the type and and the payload to be our data 

 .then(res => 
        //Inside dispatch we will set the type to be GET_ITMES and then set the payload to be res.data which is th data given to us from the backend 
        dispatch(
            {
                type:GET_ITEMS,
                payload: res.data
            }
        )
        ) 

This data is the new item being returned to us from the db


--delete iTEMS--

in our shopplnnglist we need ot change any instance of id to _id in our delete as the value of id in mongodb is _id not id

Now in the actions we will repeat again by adding our dispacth 

and then call an axios.delete request in this one we wwant to use the id variable so we can use back ticks  to pass the id into the url target

we will get a promise which gives us the response and then we will return dispatch whihc will take in curly braces and then we will set the type to be DEL_ITEMS and then the payload will be he id

export const delItems = (id) =>dispatch =>
{
    axios.delete(`/routes/api/${id}`)
    .then(res =>
        dispatch(
            {
               type:DEL_ITEMS,
               payload:id 
            }
        ))
}


Then the only change we need ot make in our reducer is that we need to remeber that mongodb creates an id using _id so we need to vhnage item.id to item._id 

items: state.items.filter(item => item._id !== action.payload )


==== Part 8 - Deploying on heroku===

Come back and finish it 


===Part 9  - Backend JWT Auth====

The first thing we need ot do is to create our user model 

in models we create a file called user.js

//Requiring Mongoose
const mongoose = require("mongoose")


//User Scehema for user fields

const UserSchema = new mongoose.Schema(
    {
        name:{
            type:String,
            required :true
        },
        email:{
            type:String,
            required :true,
            unique:true
        },
        password:{
            type:String,
            required :true
        },
        RegDate:
        {
            type:Date,
            default:Date.now()
        }
        
    }
)

let User = mongoose.model("User" , UserSchema)

module.exports = User


Then we need routes for users so we will create a file in our api folder called users.js

to bring this into our server we need to 