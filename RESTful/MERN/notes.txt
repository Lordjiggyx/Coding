Technologies used 

MongoDB
Nodejs
Reactjs
Expressjs
Reactstrap
Redux
React-transition-group
==heroku for live deployment==



===PART 1 - EXPRESS API & MONGODB===

To start we will create our package.json file using 

npm init -y 

We will then go to intstall a number of dependencies

express
body-parser - express acc has this now so you dont need it
mongoose
concurrently
nodemon*** might need to save as a dev dependency as not required for production

npm i  --save express body-parser mongoose concurrently

we need ot create to scripts to run the application in the package.json

"start": "node server.js",
"dev": "nodemon server.js",

We can then create our server.js file

---Server.js---

and in this file we can bring express mongoose and body-parser

const express = require("express")
const mongoose = require("mongoose")
const bodyParser = require("body-parser")- not needed

we then initialze express to an app variable 

const app = express()

Body parser needs middleware 

app.use(bodyParser.json()) - nshould be app.use(express.json())

--Connecting to Database--
Rather then using command line for the MongoDB i'm going to use MongoDB compass as it makes htings much easier 

Create a databas and a collection called items 

create item objects with the attributes name author and date



To conect to MongoDB

we need to create a config folder and store our mongo conection url in a file called keys.js

we then use modules.exports 

we let this export an object containing our keys for example the mongo url

module.exports = 
{
    MongoUrl:"mongodb+srv://Tomi:<Lordjiggy123.>@testcluster1-bsyse.mongodb.net/MERN?retryWrites=true&w=majority"
}
******To get your application to interact with a certain database in atlas after the .mogodb.net/ you must change the vlaue to the name of the database******

we can then bring this into our app.js file and connect to the database

to do this we create a databse variable and allow it to require the keys files and we request the mongo url

const db = require("./Config/keys").MongoUrl

we then use mongoose.connect to connect to the database

this takes in the database variable and an object called useNewUrlParser which must be set to true this returns a promise which we can just console.log the database is Connected and then a catch where we can just log the error

mongoose.connect(db , {useNewUrlParser:true})
.then(()=> console.log("Connected To Database..."))
.catch(err => console.log(err))

We can then create a variable for the port as we may use heroku to deploy it we will set this variable to an environment variable or set it to a local port of 5000

const port = process.env.PORT || 5000

then we can call the app.listem method to start the server passing in the port variable and returning a callback indicating the port is started

app.listen(port , ()=>
{
    console.log(`Server strated on port ${port}`)
})

now we will use npm run dev to strat our server


===Model===

The next thing we will be creating is a model which is a model of our data and the fields we want 

To do this we will create a folder called modles and crete a file called Item.js


In this file we will bring in mongoose and and then create a schema

const mongoose = require("mongoose")

The schema is named after the data so it will be called ItemSchema it will be set to a new mongoose schema

const ItemSchema = new mongoose.Schema(
    {
        ...
        ....
        .....
    }

This schemaa object will take a name and date field

we then create an Item variable and then set it to equal the mongoose.schemaa and this will taje in the name of the data baeing created which is an item and the schema that represents it

let Item = mongoose.model("Item" , ItemSchema)

Then we can export this using module.exports

module.exports = Item


===Routes===
We need to creat a folder called routes for our routes in the project and in this folder we will cretae a folder called API

The Api routes will return JSON 

****we are not using a template engine****

in the api older we will create a file called items.js which all our routes will go 

for this file to work we need to include it in our app.js file so the application knows where to look for it 

in our app.js we will create a variable called items.js and require the path of the items.js file 

const Items = require("./Routes/api/items")

we then want to make it so any request targeted at /routes/api to target items.js

To do this we will call app.use() and point to the items file by referencing the variable

//Use Routes
app.use("/Routes/api/", Items)

---Items.js---

We can then go into our items.js and bring in express then we must use the express router 

//Bringing in express
const express = require("express")
//Using express router 
const router = express.Router()


****Export This file using module.exports******


We must then bring in the item model in oirder to manipulate the items 

//Bringing in Item model
const Item = require("../../models/Item")

Now in the items.js file we will create our routes 


---Items routes---

The first route will be a get request to retrieve all items

router.get("/" , (req , res)=>
{
    
})

to fetch all the items in the database

we will first take the model(Item) and then use the find method

this method returns a promise and in this function it will return the items and then we will send a json response using  res.json and pass in items

we can also tag on a .sort() method in order to sort the items by date 1 for ascending and -1 for descending

router.get("/" , (req , res)=>
{
    Item.find()
    .sort({date:-1})
    .then(items =>res.json(items))
})

we then want to create aa route for creating an item this will use router.post 


router.post("/" , (req , res)=>
{

})

in here we will create an item variable set it to be a new item object and we just pass in the name variable from the request which is llowed by using body parser 


router.post("/" , (req , res)=>
{
   const newItem = new Item(
       {
           name: req.body.name
       }
   )
    console.log("Page working")
})

we can then call the newItem.save() method which will save it to the database this returns a promise which returns the object and we will send out a json repsonse seding out the item


router.post("/" , (req , res)=>
{
   const newItem = new Item(
       {
           name: req.body.name
       }
   )

   newItem.save()
   .then(item =>
    {
        res.json(item)
    })
    console.log("Page working")
})


We will then call a delete request This will be based off the id of the item

//Route for deleting a post
router.delete("/:id" , (req , res)=>
{
    //Finiding the Item to delete by ID
   Item.findById(req.params.id)
   //This returns a promise which gives us trhe found item and then a callback of what we want to happen
   .then(item =>
    {
        //We want to use thr remove method on the model and then send a message saying the item was deleted
        Item.remove()
        .then(()=> console.log("Item Deleted"))
        //We then want a catch method this method will return an err and a callback this callback will return a 404 not found message and a messgae to indicate that there was an error
        .catch(err =>res.status(404).send("Error"))
    })
   
 console.log("Page Working")
})


===Part 2 Setting up the Client and Reactstrap====

We will start to work on the front-end focusing on React

To start we need to create a new folder called Client

This is where our react app will go 

in this folder we will use create-react-app . to specify that we want to cretae a a react apploication in this folder

This package.json it creates is different from your package.json in the root folder

****When you are building a full stack app like this you need a proxy value in the package.json in the client folder *****

,
  "proxy": "http://localhost:5000/"

This way the application knows what we are talking about when we make calls to the endpoint in

--Run Both Servers--

We then want to run both servers at the same time 

to do this we can use concurrently which wil allow us to run both at the same time

To do this we open the package.json in the server side of the application and then create a few scripts 

"client": "npm start --prefix client" This is to run the client server from the server directory


 "Both": "concurrently \"npm run dev\" \"npm run client\" " This will allow us to run both servers together the backslahes are used for character escaping 

"client-intstall": "npm install --prefix client" 2 -This is done as if this app is being cloned or moved it will stop the need to reinstall the node_modules folder and run npm install 

this way you can just use npm run client install to install all the client dependencies

so we can now cd back to the root folder and call npm run both

--React Client Side--

In this folder there are extra default things we will delete the following 

logo.svg
index.css

we can go into the app.css and remove the Code

remove any sort of calls that reference deleted files 

in the app.js file we can remove all the code an djust keep the div tag and pss in hello world

import React from 'react';
import './App.css';

function App() {
  return (
    <div className="App">
     <h1>Hello World</h1>
    </div>
  );
}

export default App;

We have a few dependencies to add to the application 

we can open a new terminal and go into the client folder

now we want to install 
bootstrap
Reactstrap
uuid used for static data at the moment to genereate random numbers

npm i bootstrap reactstrap uuid react-transition-group

---Components--

We need to import bootsrap into our app.js 

import "../../client/node_modules/bootstrap/dist/css/bootstrap.css"

**Must be at proper directory path**
**If the page does not load turn the server off and on**


We will create a folder called Components in the src folder


-Navbar-
In the Components folder we will creeate a fille called AppNavbar

We will import react and the Component from react 

import React , {Component} from "react"

We will then import a few things from reactstrap

import
{
    Collpase, - This is for teh toggler in the case we add more links to a responsive hamburger menu
    Navbar, - The Navbar
    NavbarToggler, - Used in conjuction to Collpase
    NavbarBrand, - The brand for the Navbar
    Nav, - Wrap around the links
    NavItem, - wrap around nav links
    NavLink, - this wil be where the href is
    Container, bootrap container for everything
} from "reactstrap"

Then we will create our class 

class AppNavbar extends Component
{

    constructor(props)
    {
        super(props)
        this.state = {}
    }


    render()
    {
        
        return(
            <div>

            </div>
        )
    }
}

export default AppNavbar


***We will be passing in props to our navbar so we must pass in props in the navbar and hte super***

We will then create the toggle function 

toggle = () =>
{

}

The toggle funtion here has been set to an arrow function this is a work around for having to bind the the function in the constructor like you usually would and you can do this for any custom function

then in our state we can add isOpen:false , this is the variable that will halp us toggle the hamburger menu 

then in our toggle method we can use this.setState to change the value of isOpen to whatever the oppposite is to allow toglle

toggle = () =>
        {
            this.setState({
                isOpen: !this.state.isOpen
            })
        }

in our render function we will render our navbar using the react Components

First we will place the navbar in the div 

<Navbar color = "success" dark expand = "sm" className="mb-5">
            
</Navbar>

The navbar can take attributes like normal html ones wouls 
color is for the bootstrap colors success = green

expand means that it will become a hamburger menu on small screens as we set it to sm 

className mb-5 means margin-bottom 5

we place dark for the text on the page

we will then place a container in this 
then we can place our NavbarBrand and allow it to have a href to the index page 

<NavbarBrand href = "/">
      The M.E.R.N Shopping List
</NavbarBrand>

Next is the NavbarToggler we give this an onclick and pointit to carry out the toggle method

<NavbarToggler onClick={this.toggle}/>

Then we must add the Collpase we add the isOpen attributes and set it to be the value of isOpen in the state of the clsss we place navabr to let the application know that it's part of a navbar 

<Collapse isOpen = {this.state.isOpen} navbar>

then we add the nav with a class if ml auto just ot make sure that the nav bar is aligned to the left and the link is alligned to the right 

<Nav className = "ml-auto" navbar>

we then add the NavItem link to wrap the link and then the nav item , the nav item taks a href of where you want to send the client with text inside

<NavItem>
    <NavLink href= "https://youtube.com">
        Click To Go to Youtube
    </NavLink>
</NavItem>

In total the AppNavbar looks like this 


 <div>
<Navbar color = "success" dark expand = "sm" className="mb-5">
    <Container>
        <NavbarBrand href = "/">
            The M.E.R.N Shopping List
        </NavbarBrand>
        <NavbarToggler onClick={this.toggle}/>
        <Collapse isOpen = {this.state.isOpen} navbar>
            <Nav className = "ml-auto" navbar>
                <NavItem>
                    <NavLink href= "https://youtube.com">
                        Click To Go to Youtube
                    </NavLink>
                </NavItem>
            </Nav>
        </Collapse>
    </Container>
</Navbar>
</div>


Then we must go into our app.js and import this Component

import AppNavbar from "../src/Components/AppNavbar"

and then in the div we can return the AppNavbar tag 

function App() {
  return (
    <div className="App">
    <AppNavbar></AppNavbar>
    </div>
  );
}



===Part 4 - Shopping list Components and Transitions====

In our Components file we will create a new fille called shopplnnglist.js this will be a class based component

we need to import react 

//Importing react and the components
import React , {Component} from "react"

we need to import things from reactstrap

import {
    Container,
    ListGroup,
    ListGroupItem,
    Button
} from "reactstrap"

Then we need to import things from react-Transition-group
import { CSSTransition , TransitionGroup} from "react-transition-group"


we import uuid for our list items id's
import uuid from "uuid"

We can start by creating the shopplnnglist Component

At the momeent we will hardcode the data into the state 


this.state =
    {
         items:
         [
             {id:uuid() , name: "Chicken"},
             {id:uuid() , name: "Pudding"},
             {id:uuid() , name: "Rice"},
             {id:uuid() , name: "Chicken"}
         ]
    }

in our rrender method we can destructure our state and pull out the items array

 const {items} = this.state

Then in our return we can start by creating a container tag
and in this container we will create a button to add the item 

In the button tag we can add attributes one for the color and an inline style of a margin botttom of 2 rem 

then rather then creating a whole new function to handle the onclick we will use and arrow function 

in this arrow function we will create a variable that will be a prompt for the user to enter a name for the item called name 

then we will create an if statement thhat says if name exists we will change the state but in the this.setState method we will use the spread operatoron the array to add the new object to the array of Items then we close all the tags

explanation of the spread syntax here 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax

 <Container>
                <Button 
                color = "dark"
                style={{marginBottom:"2rem"}}
                onClick = {()=>
                {
                    const name = prompt("enter Item")
                    if(name)
                    {
                        this.setState(state =>
                        (
                            {
                                items:
                                [...state.items,
                                {id:uuid() , name:name}
                                ]
                            }
                        ))
                    }
                }}>
                        Add Item
                </Button>
            </Container>


To dispay the buttons we will go underneath the button and use a list group tag
we want to map through all the items and display each one 

<ListGroup>

we will be using the transition group tag and give it a class name of shopping-list
<TransitionGroup className = "Shopping-list"

inside this tag we will use the map higher order array funciton , we will destructure the item object and grab just the name and id of the items 

{items.map(({id, name}) => (


))}

for each item we will display a ListGroupItem but wee want the transition effect to occur first we will use the CSSTransition tag this will take a key which will be the id of the item is then we will set a tineout and finally it needs a classname attribute of fade then we will have to add css to the className for the fade to happen 

then inside this tag we will place the ListGroupItem tag and we will display the name

<ListGroup>
    <TransitionGroup className= "shopping-list">
        {items.map(({id , name})=> (
        <CSSTransition key = {id} timeout= {500} classNames= "fade">
        
        <ListGroupItem>
            {name}
        </ListGroupItem>

        </CSSTransition>
        ))}
    </TransitionGroup>
</ListGroup>

Before the name we will add a delete button thr button will take in properties 

a className
the colour
the size 
an onclick

  <Button
    className= "btn-del"
    color = "danger"
    size = "sm"
    onClick = {()=>{}}
    >

in th onclick we will call the this.setState method , we will take the current state and then the items variable and the state of this value we will use ht filter method to return a mew array without the clicked item

This method returns each item along with a condition , this condition will be if the item id is not equal to the id, whatever item we click on will actually remove the item from the UI 

 onClick = {()=>
{
    this.setState(state =>(
        {
            items: state.items.filter(item => item.id !== id)
        }))
}}

we can then go to our app.css and edit the button and make the fade transition happen

.fade-enter{
opacity: 0.01;
}

.fade-enter-active
{
opacity: 1;
transition: opacity 1000ms ease-in
}

.fade-exit{
    opacity: 1;
    transition: opacity 1000ms ease-in
}

.fade-exit-active
{
    opacity: 0.01;
}

fade-enter & fade-enter-active are the tramsitions that happen wehen we add an item to the list we want it to start off as invisible usin the opacity property and then become visible we set the duration to be one second or how long you wnat it

the fade-exit and fade-exit-active is the opposite when we delete an item

We then must go to our app.js and add the component


====Part 5 Implementing Redux====

CARS = Component => actions => Reducer => store

We are Implementing redux in order to create a component called an item modal component which will interact with our redux state , There is a lot of boilerplate 

To start we need to install a few things
***We must be in the client Folder***

redux - The redux itself
react-redux what binds the two
redux-thunk - middleware for dealing with back end for dispatching from actions to our reducer when we want to make async calls

we must intsall redux , react-redux , redux-thunk

npm i --save redux react-redux redux-thunk

Then in our src folder in the client folder we will cretae a file called store .js

This will be the starting point of our redux store , the only way to cahnge this is by calling an action

so in this store.js file we need to import  a few things


import {createStore , applyMiddleware ,compose} from "redux"
import thunk from "redux-thunk"
import rootReducer from "./Reducers/index"

we eill create a variable to represent our initail state 

const iniialState = {}

Then a variable for middleware being used and we will store these in an arrau

const middleware = [thumk]

Then a variable called store and set it to be our createStore function , this will take in three things our rootReducer , iniialState and any middleware but since were using redux tools we will pass the applyMiddleware into the compose function and in this applyMiddleware function we can pass in thunk using the spread Operator

const store = createStore(rootReducer , initialState , compose(
    applyMiddleware(...middleware)
))

To use the redux dev tools we must insert a line of code inside 

 window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()

 thne we can just export the store 

 export default store

 in oreder to integrate the store into our application we need to go into our app.js and bring in the provider, this is from react-redux 

 in order to use redux in our components and manipulate state we must wrap everything in the provider tag , this tag takes in a property of our store  

 
function App() {
  return (
    <Provider store = {store}>
    <div className="App">
    <AppNavbar></AppNavbar>
    <ShoppingList></ShoppingList>
    </div>
    </Provider>
  );
}

This will allow us to access state from the components

next we will create the rootReducer this will be done in the src folder we will create a folder called reducers and then a file called index.js

The main point of this is to bring together all the other reducers , this is a simple app so we only have itemReducer if we were to add authentication or manage errors we might need an authentication reducer of error reducer.

so to start we will import combinereducers
import {combineReducers} from "redux"

and then itemReducer which we have not created yet but we will 

import itemReducer from "./itemReducer"


Then we will export combineReducers and pass in an object with the different reducers and we will set itemReducer to a value called item which will help us identify it within components when we wnat to use it

Next we will creeate our itemReducer in the reducers file called itemReducer.js

******************************************************************************
A reducer is where our actual state is going to be , this is wher we check our actions , we will have an actions file which will contain our actions for getting items or adding items actions and dispatch to our reducer , it can send a payload 

So say we were to fetch data from our server for the grtting items we would then dispatch to the reducer and send the response from our server to the reducer and then manipulate it within react in our components
******************************************************************************

So Going back to this itemReducer.js file we will create our iniialState this will be an object with an items array 

const initialState= 
{
    items:
         [
             {id:uuid() , name: "Chicken"},
             {id:uuid() , name: "Pudding"},
             {id:uuid() , name: "Rice"},
             {id:uuid() , name: "Chicken"}
         ]
}

***You need to import uuid***


in this reducer we need to evaluate action types , so we need to create types 
we will cretae a folder called actions in the src file 

and in this file we will have afile called types.js this can also be called "constants" , they are just constants set to strings that we export

export const GET_ITEMS = "GET_ITEMS"
export const ADD_ITEMS = "ADD_ITEMS"
export const DEL_ITEMS = "DEL_ITEM"

***Any thing you do in your application you will add an actionn type for***

We can then bring this inot our item reducer

back into the itemReducer.js we will import the actions
import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS } from "../actions/types"

in our itemReducer.js we want to export a fucniton this function takes two paramaters first is the state whihc we will set to our initial state and then secondly it will take an action object which will have a type attached to it from the actions file that we haven't created yet 

export default function (state =initialState , action)
{
   
}


in this function we will have our switch statement when the action comes in we wnat to run a test on the type , as actions is an object we can access the type using actions.type and we will check for the action name 

at the momeent with the GET_ITEMS we will just use the spread Operator to return the current state this will be changed when we connect to the backend 

 switch(action.type)
    {
        case GET_ITEMS:
            return {
                ...state
            }
        default:
            return state;
    }

Next we want an actions file in our actions folder called itemActions.js this is where we wil be maing backend requests

we need to import our tuypes into the file

import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS } from "../actions/types"

we can then export an arrow funciton whihc returns the type to the reducer in this case it will be GET_ITEMS

export const getItems = () =>
{
    return{
        type:GET_ITEMS
    }
}


This goes to our itemReducer and checks action.type 

now we want is to call the getItems from our component instead of getting it from the state we want to grab it from our itemReducer

Now in our ShoppingList component we must make a few chnages 

first we must import connect from react redux this allows us to get state from redux into a react component 

import {connect} from "react-redux"

Then we need to import the getItems action this is being taken from the actions folder and the itemActions file 

when we use connect like this instead of exporting the actual clsss we want to export connect with parentheses which will take in two things a function called mapStateToProps which is a function we haven't created yet and thne it will take in any actions we want to use in this case being getItems and then the class naem wrapped around in brackets 


export default connect(mapStateToProps , {getItems})(ShoppingList)


What mapStateToProps allows us to take our state in itemReducer and map this into a component property which will let us access it it using this.props.items


we must create the function mapStateToProps, this will use an arrow function and it takes in state and then we want to set it to parentheses and then pass in an object and then we want to set item to state.item **We use state.item cause that is what we called the reducer in th rootReducer**

const mapStateToProps = (state) =>
({
    item:state.item
})

next we want to bring in our prop types whenever you have component properties they should be put into prop types which is like a form of validation 

import PropTypes from "prop-types"

Then underneath the class we can then  type shopplnnglist.propTYpes and set it to {} we have two props in this component , the first is getItems , when you bring na action from redux it's stored as a prop so we can set this to PropTypes.func.isRequired  and then set item to PropTypes.object.isRequired

ShoppingList.propTypes = 
{
    getItems: PropTypes.func.isRequired,
    //This is our state which is an obejct
    item: PropTypes.object.isRequired
}



The last thing to run get items

to do this we want to run it in a componentDidMount function call within our class

componentDidMount()
{
    this.props.getItems()
}


we must now cahnge the way we accessed the items by using 

this.props.item.items

item represents the state object 
items is the array inside the state

so we can use destructuring again just target a different object this time

 const {items} = this.props.item





To help you better understand how redux is working in this application you must remember that the ShoppingList COMPONENT is connected to the Redux store through connect. So, when you click the delete button it fires the deleteItem ACTION. In his tutorial, he has the dispatch inside his action creator, so the action itself will initiate the STORE to call the reducer. The REDUCER will then check which action will be executed then return the correct behavior to the STORE. It looks a little something like this:
Component (click) --> Action(dispatch) --> Store (sends action to reducer) --> Reducer (returns new state AS item) --> Store


===Part 6 Finsihing Redux===

first thing we want to do is the delete

we will rmeove uuid remove any instance of uuid in the component and then renmove the button as we will create a separate component for adding items

in our shopplnnglist component we will bring in the delItems actions along with getItems at the top

import {getItems , delItems} from "../actions/itemActions"

 and also include in the export at the bottom 

 export default connect(mapStateToProps , {getItems , delItems})(ShoppingList)

 Now we go to our itemActions.js and then create a new const called delItems this wiill take in an id to identify which element to delete  and change the type tO DEL_ITEM

export const delItems = (id) =>
{
    return{
        type:DEL_ITEMS
    }
}


 To get the id we must send along a playload if the id that i spassed into the function 

export const delItems = (id) =>
{
    return{
        type:DEL_ITEMS,
        payload:id
    }
}


  This is returining to the reducer so we must go to the reducer and check for DEL_ITEM. we must now add a case for delete 

  case DEL_ITEMS:
            return {
                
            }

To start we want to grab the state using the spread Operator then

 case DEL_ITEMS:
            return {
                ...state
            }

then we eill take the items and then calle the filter method on them and then do what we did previosuly returning an item and each time the item is retuerned we check that the id of it does not equal the value of the clicked identify

in this case however in our action we passed in a payload whihcwe can access using action.payload

case DEL_ITEMS:
            return {
                ...state,
                items: state.items.filter(item => item.id !== action.payload )
            }


Then going back to our component we will change the onclick to a function we create called onDeleteClick , this method must take in the id of the clicked item and to do this we can use bind and pass in this and id 


 onClick = {this.onDeleteClick.bind(this , id)}

 then we can create the method we set this this will be an arrow function whihc tajes in the id and then it calls the action delItems passing in the id

 onDeleteClick = (id) =>
{
    this.props.delItems(id)
}

This then sets the type to DEL_ITEMS and creates a payload with the id value inside this then called the reducer which exceutes the delete method which is explained above 


In our components folder we will create a new file called itemModal.js

in this file we will import react and a number of components from reactstrap


import React, { Component } from 'react'
import {
    Button,
    Modal,
    ModalHeader,
    ModalBody,
    Form,
    FormGroup,
    Label,
    Input
  } from 'reactstrap';

  

  A container is a component that is hooked to redux if you are using redux state in a component it is called a container


  we must import connect and the additem action which we have not created yet 

import { connect } from 'react-redux';
import { addItems } from "../actions/itemActions"

  To start we will give the modal state and we will set modeal to false this represents if the modal is open or not we will have a form which will have the item name so we need to give our component state too , in the case where you have a form you want the input to have state in the component 

  
    state = {
        modal: false,
        name : " "
    }
   
   , we will also have a toggle like the navbar and allow it to vhnage the modal vakue to the opposite of it's current value

   toggle = () =>
   {
       this.setState(
           {
               modal = !this.state.modal
           })
   }



Then in our render method we will place a button within our div , this button wil open the modal same button as our last one


 <Button 
color = "dark"
style={{marginBottom:"2rem"}}
onClick ={this.toggle}
>
Add Item
</Button>

under the button is where we will place the modal 
it will take a few paramaters 

isOpen - set to this.state.modal to tell uf the modal is open or not
toggle - set to toggle function


<Modal
isOpen = {this.state.modal}
toggle = {this.toggle}
>

After the modal we will have the modal header this will also have a toggle attribute in it

<ModalHeader toggle = {this.toggle}>
Add to Shopping list
</ModalHeader>

then we will have the ModalBody
inside the ModalBody we will have a form this form takes an onsubmit attribute and we will set this to a mtehod called onsubmit that we wil create 

  <Form onSubmit = {this.onSubmit}>


inside the form tag we will place a FormGroup tag and inside this FormGroup we will use the Label and Input tags the Label will have an attribute called "for" and this will be set to item 

<Label for = "item">
Name
</Label>

The input will take in a few attributes
type - text
name - this value should match the name of the state you are affecting
id- set to item
placeholder- whatever you want

onChange - In react when you have an input you want ot set it to a function called onChange whihc we will create 

 <Input
type = "text"
name = "name"
id = "item"
placeholder = "Enter Item"
onChange = {this.onChange}
/>

Then we will create a button just for submitting the name to the state 

 <Button
color = "dark"
style={{marginTop:"1rem"}}
block
>
Submit
</Button>

we use block so it fits the whole container


We will then cretae the onChange and onSubmit methods 


The onChange will be set to an arrow function this will take in an event paramater inside the function we will use this.setState , we're actually going to use e.target.name this targets the name of the input which should have a matching vlaue in thwe state so if we had multiple inputs we would not have to create multiple functions for one input. Then we can set this to be the e.target.value

onChange = (e) =>
   {
       this.setState(
           {
              [ e.target.name]:e.target.value
           }
       )
   }

The onsubmit will also be an arrow function that takes in an event paramater, we first need to prevent the form from acting how it would naturally at the momeent were not dealing with the backend so we will create an item with a uuid ID and the name value will come from the state when we type into the input it updates the state name 

const newItem = 
{
id:uuid(),
name:this.state.name
}

we now will add the item through the addItem action to do this we use this.props.additems() and then pass in newItem 

 this.props.addItems(newItem)

 and then you can close the model using this.toggle



  before we create our addItems action we need to export our component with model withn connect and create a mapStateToProps function 

  we must create the function mapStateToProps, this will use an arrow function and it takes in state and then we want to set it to parentheses and then pass in an object and then we want to set item to state.item **We use state.item cause that is what we called the reducer in th rootReducer**

const mapStateToProps = (state) =>
({
    item:state.item
})

then to export our object we must use connect passing in this mapStateToProps functino along with the addItems action and then the itemModal

  export default connect(  mapStateToProps, { addItem } )(ItemModal)

Now we must go to our itemActions.js and create the add item 

export const addItems = (item) =>
{
    return{
        type:ADD_ITEMS,
        payload:item
    }
}

instead of id this action will takje in the whole item , and the type we want to return to the reducer is ADD_ITEMS and along with that a payload if the item object itself


Then we must go to our redcucer and then create a case for ADD_ITEMS and we want to return the current state using the spread Operator and then set items to equal the item from the action.payload and use the spread Operator to add it to the state of the items 

Then in our app.js we can import and add the itemModal

====Part 7 - Connecting to the backend====

Now we will Implement the backend by making requests to it from the front end by doing this in the actions 

in the itemredcucer.js we will get rid of the static data and add a loading value and make this boolean

we need another type in pur types and this will be called ITEMS_LOADING

import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS , ITEMS_LOADING} from "../actions/types" 

and we will have to create this in our action types

export const ITEMS_LOADING = "ITEMS_LOADING"

Then back in our itemReducer.js we will add ITEMS_LOADING as a case , all this will do will cahnege the isloading value in the state to true 

  case ITEMS_LOADING:
                    return {
                        //we use spread to get current state 
                        ...state,
                        //Then we can just set the state of the loading value to eqaul true 
                        loading:true
                    }

Then in our itemActions.js we need ot create another funciton called setLoading

to start we must bring in ITEMS_LOADING at the top

import {GET_ITEMS ,ADD_ITEMS , DEL_ITEMS  , ITEMS_LOADING} from "./types"

and then we will create the function exporting it at the same time this will be an arroe function
all this function will do is retun the type of ITEMS_LOADING which ultimate;y sets it from false to true 

--GET_ITEMS Action--

Now we will fetch the items to make requests we will use axios , to use axios we must first install it using npm i --save axios and this should be done within the client side 

onec this is installed we need to import it into our file using 

import axios from "axios"

Then we will add another arrow function and add dispatch to the function 

export const getItems = ()=> dispatch =>
{

}

we want to call setLoading by using dispatch() and passing on setLoading() into this method

dispatch(setLoading())

we can then make our axios request using axios.get in here we will pass in the route from our back end that fetches the data which was "/routes/api/items"

axios.get("/routes/api/items")

this will then return a promise using .then 
and in here we will be given our response obejct in which we will return
 dispatch()

and inside the dispatch we will pass in curly braces and set the type which will be GET_ITEMS and then set the payload to res.data whihc is the data given to us from the back end when we make this request 
.then(res => 
        dispatch(
            {
                type:GET_ITEMS,
                payload: res.data
            }
        )
        ) 

Then we go to the reducer and go to our GET_ITEMS case we now want to get the items array which is blank and populate it with the new items from the action.payload

items:action.payload,

We then want to set isloading to false which shows that the fetching has been finished 


--Add items--
This will be the same thing in our itemredcucer.js

we will add the dispatch 

export const addItems = (item)=>dispatch =>

then we will make an axios post request to our target route which is the same 
"/routes/api/" we need to pass along data whihc is our item and htis will be passed into the axios.post request 

axios.post("/routes/api/" , item)

but we need to go to our onsubmit method in our item modal we want ot remove the uuid cause MongoDB creates the id for us

now a promise is returned again giving us a response and then we will do the same thing again setting it to dispatch and again passing in curly braces where we set the type and and the payload to be our data 

 .then(res => 
        //Inside dispatch we will set the type to be GET_ITMES and then set the payload to be res.data which is th data given to us from the backend 
        dispatch(
            {
                type:GET_ITEMS,
                payload: res.data
            }
        )
        ) 

This data is the new item being returned to us from the db


--delete iTEMS--

in our shopplnnglist we need ot change any instance of id to _id in our delete as the value of id in mongodb is _id not id

Now in the actions we will repeat again by adding our dispacth 

and then call an axios.delete request in this one we wwant to use the id variable so we can use back ticks  to pass the id into the url target

we will get a promise which gives us the response and then we will return dispatch whihc will take in curly braces and then we will set the type to be DEL_ITEMS and then the payload will be he id

export const delItems = (id) =>dispatch =>
{
    axios.delete(`/routes/api/${id}`)
    .then(res =>
        dispatch(
            {
               type:DEL_ITEMS,
               payload:id 
            }
        ))
}


Then the only change we need ot make in our reducer is that we need to remeber that mongodb creates an id using _id so we need to vhnage item.id to item._id 

items: state.items.filter(item => item._id !== action.payload )


==== Part 8 - Deploying on heroku===

Come back and finish it 


===Part 9  - Backend JWT Auth====

The first thing we need ot do is to create our user model 

in models we create a file called user.js

//Requiring Mongoose
const mongoose = require("mongoose")


//User Scehema for user fields

const UserSchema = new mongoose.Schema(
    {
        name:{
            type:String,
            required :true
        },
        email:{
            type:String,
            required :true,
            unique:true
        },
        password:{
            type:String,
            required :true
        },
        RegDate:
        {
            type:Date,
            default:Date.now()
        }
        
    }
)

let User = mongoose.model("User" , UserSchema)

module.exports = User


Then we need routes for users so we will create a file in our api folder called users.js

to bring this into our server we need to do what we did with our server routes
 by first requiring the routes route into the app 

 const Users = require("./Routes/api/users")

 and then calling the app.use on this file path pasing in users varibale too

 app.use("/Routes/api/", Users) 

 in our users.js we can copy items.js and just chnage accordingly
 
 we should also install bcrypt  using npm i  --save bcrypt this will be used for hashing our passwords 

 we will create a route for registering/cretaing a user 

 router.post("/register" , (req , res) =>
 {

 }

we will use req.body to get our user value and using destructuring we can pull the name email and password from this

 const {name , email ,username, password , password2} = req.body
 
 we will also do some basic validation checking if all fields are entered and if not send a message asking the user to enter all fields alpng with a status 400

  if(!name || !email || !password)
   {
       return res.status(400).json({msg:"Please Enter All Fields"})
   }

if they do fill fields we will use the user model and check for an existing user by email using User.findOne({email:email}) 

this will give us a promise returning a user if there is a user we will return a 400 status and a message to tell the clinet that the user already exists

 .then(user =>
    {
        if(user)
        {
                return res.status(400).json({msg:"User Already Exists"})
        }
    }
   )



if the user does not exist we will create a new user using our User model passing in th naem email and password fields 

 else
        {
            const newUser = new User
            (
                {
                    name , email , password
                }
            )
        }

we will then bring in bcrypt using 

now to encrpyt the password we need to generate a salt to create a hash there are two methods we will use 

the bcrypt.genSalt this takes in a 10 and then a call back with an wrror and a salt this call back will call the bcrpyt.hash method this will take in our password and the salt this will also give use a call back with a possible error we will set the newuser password to the hash value 

we can then call the save method on this user as this is method in the mongoose models 

this will return a promise in which we will sned the user back 

const bcrypt = require("bcrypt")

thne the bcrypt code 
bcrypt.genSalt(10 , (err ,salt)=>
    {
    bcrypt.hash(newUser.password , salt ,(err , hash)=>{
       if(err)
      throw err

      //set passowrd to hashed
      newUser.password =hash
      //save User
      newUser.save()
      .then(user=>
        {
            //Just sending the respnse of the user object 
           res.json({
               user:{
                   name: user.name

               }
           })
        })
      .catch(err =>
        {
            throw err
        })
            
        })
    })


Now we want to implement tokens 

to start we will install jsonwebtoken using npm i --save jsonwebtoken and thrn install config using npm i --save config

we can create a json file called default.json instead of keys.js  and we can place a json object inside 

inside this json object we can place any keys any url's anything we we will take our mongourl inside along with a jwt seceret value 

just for auth purposes we will no longer use keys.js ***dont dlete just comment out*** in serevr.js 

so we can just require config 

const config = require("config")

then we can get the MongoUrl using 

const db = config.get("MongoUrl")

in our users file we can also bring config again

then we can bring in the json web tokens

const jwt = require("jsonwebtoken")

then just after we save the user in the respnse is where we wnat to creaet a token right above the res.json

we will call jwt.sign the first paramater will be the payload this cna be whatever you want , we wnat to make this a json object with a paramater of id snd set it to the user id 

in this case when we send a token from react the user id is in there so it knows which user it is.

next paramater is oging to be the seceret valkue which will be the value in our config

The last paramater is the last paramater is if you want it to expire in which we do we set this to 1800 secsonds which is 30 mins

The final paramater is a callback which gievs us a possible error and a token this is where we will actually send our respnse inside here 

jwt.sign(
{id:user.id},
config.get("jwtSecret"),
{expiresIn:3600},
(err , token) =>
{
    if
    (err) throw err
        //Just sending the respnse of the user object
    res.json({
        token,
        user:{
            id:user.id,
            name: user.name,
            email:user.email

        }
    })
}

)

So when we register we get a user and a token which we can then use to authenticate private routes 

We can write custom routes to make routes private


We now want ot login and get a token from logging in
we cretae  a new file called auth.js in the routes folder

we can take a lot from the the users.js just we will change the routes and the validation as we we'll only be comparing the email and password

Then we will  search for a user by email address  amd return an error messgae of the user does not exist

 User.findOne({email:email})
   .then(user =>
    {
        //If there is no user we'll display a message indciating the use rodes not exist
        if(!user)
        {
                return res.status(400).json({msg:"User Does not exist"})
        }
    }

Next thing we wnat to do is actually compare the hashed password to the plain text password entered form the req.body object

we will use the bcrypy.compare method an dwe will check  if the passwords match and if the user exists or not 


bcrypt.compare(password , user.password)
        //This returns a promise and gives us a boolean which we will call Match
        .then(Match =>
            {
                //If the password does not match we will send a response indicated the passwords do not match
                if(!Match)
                {
                    return res.status(400).json({msg:"Invalid Credentils"})
                }
                //If the passowrd matches we send the user and the token
                else
                {
                    //Cretaing a JWT token
            jwt.sign(
                //Passing in user id as a payload
                {id:user.id},
                //jwt secert
                config.get("jwtSecret"),
                //Toke expires in 30 minutes
                {expiresIn:1800},
                //callback
                (err , token) =>
                    {
                        if
                        (err) throw err
                         //Just sending the respnse of the user object and a token
                        res.json({
                            token,
                            user:{
                                id:user.id,
                                name: user.name,
                                email:user.email
             
                            }
                        })
                    }
            
            )
                }

            })

We then need to make this file avaliable to our server.js 

first we require it 

const Auth = require("./Routes/api/auth")

then we bring it in

app.use("/Routes/api/", Auth)

The last thing ot do is to create middleware to have private routes taht can only be accessed along with the token 

in the routes folder we create a folder called middleware andinsde we cresate a file called auth .js

in this file we bring in config and our jwt

const config = require("config")
const jwt = require("jsonwebtoken")

Then we crete a middleware function called auth taht takes in req res and next 

function auth (req ,res , next)
{

}

in this function we will create a variable to represent the token coming in 
this is taken from the header object in the request object and the token has a vlue of x-auth-token

 const token = req.header("x-auth-token")

 Then we will check if the token exists
 if the token does not exist we will send a 401 response indicating that there is not token present and the access is denied 

 insdie a try catch we will create what happens if the toke does exost 

If the token does exist we will create a variable vcalled decoded which calls the jwt.verify method on the token and checks the tokens secert

const decoded = jwt.verify(token , config.get("jwtSecret"))

we then want the user from the token and set this to be the req.user 

req.user = decoded

Then we call next 
next()

in the catch we will pass in the event value and then send a response of 400 telling the user the token is invalid if there is an error

finally we wnat to export the middleware function 

module.exports = auth

So now we can require this into any file and add it as a second paramater to any route to secure it 

for example in our items routes we wnat the adding and deleting of items to be authenticated

so we will require auth into the file 

const auth  = require("../middleware/auth")

and then add auth to any route

We want to create a route in the auth.js 
This route will get the current users data by using the token , jwt authentication is stateless , so we need a route that takes the token and returns the user


so in auth.js we will bring in the auth middleware 

and we will create a route this will be a get request

router.get("/auth",auth ,(req , res)=>
{

})

Then we will call user.findById
we do not want to show the passowrd so we can use .select("-password") to exclude this , then a promise will be returned along with a user object we can then send a response of user 

router.get("/auth",auth ,(req , res)=>
{
    //find the user by passing in the user id from the req.user object
    User.findById(req.user.id)
    //We do not want the password so we can use .select()
    .select("-password")
    //This will send a promise with the user and we will send a response of the user object
    .then(user =>res.json(user))
})

===Part 10 - React & Redux AUTH State===

Before we create a modal component for login and registration  we should manage the state 

so back in the client.

We have two new Reducers and Auth reducer and an error reducer each which there own actions

To start we go to our types.js we need to create in a number of types for the logn and registration process

export const USER_LOADING = "USER_LOADING";
export const USER_LOADED = "USER_LOADED";
export const AUTH_ERROR = "AUTH_ERROR";
export const LOGIN_SUCCESS = "LOGIN_SUCCESS";
export const LOGIN_FAIL = "LOGIN_FAIL";
export const LOGOUT_SUCCESS = "LOGOUT_SUCCESS";
export const REGISTER_SUCCESS = "REGISTER_SUCCESS";
export const REGISTER_FAIL = "REGISTER_FAIL";
export const GET_ERRORS = 'GET_ERRORS';
export const CLEAR_ERRORS = 'CLEAR_ERRORS';

Then we need to create  our reducers in the reducers folder

authReducer
errorReducer

then in the index.js we need to bring in the two reduxers

import AuthReducer from "./AuthReducer"
import ErrorReducer from "./ErrorReducer"

then we need to add them to our combine reducers method 


export default combineReducers(
    {
        item:itemReducer,
        auth: AuthReducer,
        Error: ErrorReducer
    }
)


The error reducer is simple so we will start with this 

so in this file we will import GET_ERRORS and CLEAR_ERRORS from actions types

import {GET_ERRORS , CLEAR_ERRORS} from "../actions/types"

Then we will create a state for this reducer with a message object a status value of null and an id for errors of value null

const initialState =
{
    msg:{},
    status:null,
    id:null
}

we must then create a function which takes in the state value and set it to the iniialState value and an action which is taken from the action file , this function must be exported

//This fucntion sets the state that it takes in to the atate current state
export default function (state =initialState , action)

we must then create a switch statement to evaluate the action type

{
    switch(action.type)
    {
        
    }
}

Then we will create cases for each action type

for get errors we will change the atte by returning a message status and id all from the payload 

 case GET_ERRORS:
    return{
        //This will be a msg from the action payload which will be an object with a message from the server
        msg:action.payload.msg,
        //Also come from the payload
        status:action.payload.status,
        //Also from payload
        id:action.payload.id
    }

Thw clear errors action will just clear message obejct and set each other value to null

case CLEAR_ERRORS:
    return{
        //Sets the message object to an empty object
        msg:{},
        //makes status null
        status:null,
        //makes id null
        id:null
    }


On defualt behavior we will just return the state

default:
            return state


Next for the auth redcucer


we will bring the in the necessary actions

import {
    USER_LOADED,
    USER_LOADING,
    AUTH_ERROR,
    LOGIN_SUCCESS,
    LOGIN_FAIL,
    LOGOUT_SUCCESS,
    REGISTER_SUCCESS,
    REGISTER_FAIL
  } from '../actions/types';

Then for the state we will have an object with the following values

token
isAuthen
isLoading
user

we must then create a function which takes in the state value and set it to the iniialState value and an action which is taken from the action file , this function must be exported

we must then create a switch statement to evaluate the action type

{
    switch(action.type)
    {
        
    }
}

***Cases explained in the file for authReducer***


Now with every request we want to constanly try load the user so we wil cretea n action called load_user


in the actions folder we will cretae two new files authactions and erroractions.js

first is the auth actions so in this filw we will import axios 

//Importing axios
import axios from "axios"

and then we will import all our types

//actions
import {
    AUTH_ERROR,
    LOGIN_SUCCESS,
    LOGIN_FAIL,
    LOGOUT_SUCCESS,
    REGISTER_SUCCESS,
    REGISTER_FAIL,
    USER_LOADING,
    USER_LOADED,
  } from '../actions/types';

  The first thing we wnat to do is to check the token and load the user and to do this we need to make a request to /api/auth/user

we will create a helper method at the bottom called tokenConfig this will get the token from our state and add it to the header and then if there is a token we will set the x-auth-token value in the config header object to be the token from our state

export const tokenConfig = getState => {
    //Geting token frpm local storage
    //This looks at the auth reducer
    const token = getState().auth.token

    //We can add the token to the header
    const config = 
    {
       headers:
       {
           "Content-type":"application/json"
       }
    }

    //if token exists we add it to the headers 
    if(token)
    {
        //We want to set our headers token to the token in our state which will be ultimately the token stored in loclastorage
        config.headers["x-auth-token"] =token
    }
}


We will create a function called loadUsser which will be an arrow function this will take in dispacth and getState as we are making an async request - explained in file

//Exportable function which will need dispatch as we are making an async request
export const loadUser = () => (dispatch , getState) => 
{
    //First we will do is dispatch user loading which changes the value of laoding form false to true

    //User loading - this will call the case of user loading in our auth reducer
    dispatch({type:USER_LOADING})


  //Fetching the usser using axios.get request  
  axios
  //TARGERT THE URL /routes/api/auth we must also pass in our token which
  .get('/routes/api/auth', tokenConfig(getState))
  //We will dispatxh user loaded
  .then(res =>
    dispatch({
      type: USER_LOADED,
      //The payload will be the user object and the token object
      payload: res.data
    })
  )
  //If there is an issue
  .catch(err => {
    //We will return Auth Error which will clear out the auth state 
    dispatch({
      type: AUTH_ERROR
    })
  })

  Any error we get we want ti run it through our errorReducer so we must di it through our erroractions 

  first we must import our types

  //actions
import {GET_ERRORS , CLEAR_ERRORS} from "../actions/types"


The nwe will crete a function to return our errors

this will take in a message the status and an oprional id whic will be null by default , then we will return the type of GET_ERRORS and then the payload whihc will include everything 

// RETURN ERRORS
export const returnErrors = (msg, status, id = null) => {
  return {
    type: GET_ERRORS,
    payload: { msg, status, id }
  }
}


Then we will crete a method to clear the errors this takes no paramaters and it will just return the type of clear errors

export const clearErrors = () => {
  return {
    type: CLEAR_ERRORS
  }
}

Back in our authReducer if we get an error we want to call returnErrors which will call GET_ERRORS from the errorReducer which will put the everything from the action into the errorReducer state 

we must go to our authActions and import returnErrors

import { returnErrors } from  "./errorActions"

and we can then call it in the catch just before we dispacth the auth errors

//We dispatch return errors , which returns an object 
//This function takes in a message status and id if an eror occurs and this will be stored in the err value above m err.response.data will give us the message and err.response.status will pass in the status

    dispatch(returnErrors(err.response.data, err.response.status));

In our app.js we bring in the loadUser action

import {loadUser} from "./actions/authActions"

we will call this action when the app renders using componentDidMount

 componentDidMount() 
  {
    store.dispatch(loadUser())
  }

Now in the console we will see our actions happening in the redux tools and if we try add or delete items we will get a 401 error and the unauthorised message and also when we mount the application we will get an error message because thee is no token present as we have not creted a user


===Part 11 - React registration ===
Now we must make our components for login and register
in our components folder we will creaet a folder called auth and in this older we will create a file called reg.js for our registration modal

---REGISTER COMPONENT----

We will start with Reg.js
we can take a lot from our itemModal and paste itinto Reg.js

***Changes***
1. We wont need additems action in any case

2. State will have more paramaters email password and error

3. We must bring in propTypes

import PropTypes from "prop-types"

4.Change class name to Reg and export name to Reg

5. We want to bring in the value of isAuthenticated as we want to close the modal once we have registered if we are authenticated. so in our mapStateToProps variable we can change item to isAuthenticated and set its to eqaul state.auth.isAuthenticated


6. We also want to bring the error state so we can bring in the error state and set it to the state.error

const mapStateToProps = state => ({
    isAuthenticated: state.auth.isAuthenticated,
    error: state.Error
  });

******THE AUTH AND ERROR ARE BEING TAKEN FROM THE rootReducer WHICH GIVES US ACCESS TO THE STATE WITHIN THE AUTH AND ERROR REDUCER AND ALL THERE VALUES*****

7. Add propTypes just beloww the state

   //Setting the prop types
    static propTypes = 
    {
        isAuthenticated:PropTypes.bool,
        error: PropTypes.object.isRequired
    }

8. Remove the newItem and add item action from the onsubmit

9.We do not want a button for register we want a nav link so we must bring this in from reactstrap at the top and then replace the button with a navlink with an onclick handler which will be set to this.toggle an da href to nothing  , this way we can just place it in the nav bar

<NavLink onClick={this.toggle} href = "#">
Register
</NavLink>

10.Thhe modal will get the following changes 
    10.1 Model header name changed to register
    10.2 The name will be the first value changed the name an did to name and the placeholder
    10.3 Copy name input and add email and pssword fields

11. We will have an register action called register from the authActions file when the client submits there values 

first we will import the register action and in order to use it we need to place it in our connect down the bottom 

import {register} from "../../actions/authActions"

export default connect(
    mapStateToProps,
    {  register}
  )(Reg);

We will then make this a prop so we need to add it to propTypes up at the top to access it

register: PropTypes.func.isRequired


12.
in the submit we get the name email an dpassword from the state


 const {name , email,password} = this.state

Then we cretae a user object

//Creating new user 
      const newUser = {
          name,
          email,
          password
      }

 Then we call the register action 

//Register user
      this.props.register(newUser)



13. If there is an error we want error messagae from the server to display in the modal

we will use componentDidUpdate this will take in prev props

we will pull out error from our props

componentDidUpdate(prevProps)
{
    const {error} = this.props
}

Then we will check if the error is different from the previous error,
then we will check if the error id is REGISTER_FAIL and if it is we will call this.setState and set the msg to error.msg.msg as in the redux tools the error message is in the error message

 if (error !== prevProps.error) {
      // Check for register error
      if (error.id === 'REGISTER_FAIL') {
        this.setState({ msg: error.msg.msg });
      } 

if the message has somehting in it we want it to display it in an alert whihc we will bring in alert from reactstrap up the top

then above the form we will use a ternary update to return an alert if the state has a message inside


{this.state.msg ?
(<Alert color= "danger">
    {this.state.msg}
</Alert>)
:
null}



Then we go into our appnavabr.js and then import our Reg.js file

import reg from "./auth/Reg"

Then we can replace our navlink with a Reg component

 <NavItem>
<Reg></Reg>
</NavItem>


We can create the register action in our authActions file 
****EXPLAINED IN FILE****